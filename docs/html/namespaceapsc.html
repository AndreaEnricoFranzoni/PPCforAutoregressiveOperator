<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PPCforAutoregressiveOperator: apsc Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PPCforAutoregressiveOperator
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespaceapsc.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">apsc Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapsc_1_1internals.html">internals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a41b7e16da6e40f3910c8bed509459e0a" id="r_a41b7e16da6e40f3910c8bed509459e0a"><td class="memTemplParams" colspan="2">template&lt;typename RAIterator, typename Key, typename ExtractKey, typename ExtractValue, typename CompareKey = std::less&lt;Key&gt;&gt; </td></tr>
<tr class="memitem:a41b7e16da6e40f3910c8bed509459e0a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a41b7e16da6e40f3910c8bed509459e0a">interp1D</a> (RAIterator const &amp;begin, RAIterator const &amp;end, Key const &amp;keyVal, ExtractKey const &amp;extractKey, ExtractValue const &amp;extractValue, CompareKey const &amp;comp=std::less&lt; Key &gt;())</td></tr>
<tr class="separator:a41b7e16da6e40f3910c8bed509459e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42f1a3f2a0ca0a664a4efb87c73b2d3" id="r_af42f1a3f2a0ca0a664a4efb87c73b2d3"><td class="memTemplParams" colspan="2">template&lt;typename A, typename CompOper = std::less&lt;double&gt;&gt; </td></tr>
<tr class="memitem:af42f1a3f2a0ca0a664a4efb87c73b2d3"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af42f1a3f2a0ca0a664a4efb87c73b2d3">interp1D</a> (std::vector&lt; A &gt; const &amp;v, double const &amp;keyVal, CompOper const &amp;comp=std::less&lt; double &gt;{})</td></tr>
<tr class="separator:af42f1a3f2a0ca0a664a4efb87c73b2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3acb7b938f37e927b7ecf171e828463a" id="r_a3acb7b938f37e927b7ecf171e828463a"><td class="memTemplParams" colspan="2">template&lt;typename T, typename CompOper = std::less&lt;double&gt;&gt; </td></tr>
<tr class="memitem:a3acb7b938f37e927b7ecf171e828463a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3acb7b938f37e927b7ecf171e828463a">interp1D</a> (std::vector&lt; double &gt; const &amp;keys, std::vector&lt; T &gt; const &amp;values, double const &amp;keyVal, CompOper const &amp;comp=std::less&lt; double &gt;{})</td></tr>
<tr class="separator:a3acb7b938f37e927b7ecf171e828463a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a41b7e16da6e40f3910c8bed509459e0a" name="a41b7e16da6e40f3910c8bed509459e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b7e16da6e40f3910c8bed509459e0a">&#9670;&#160;</a></span>interp1D() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RAIterator, typename Key, typename ExtractKey, typename ExtractValue, typename CompareKey = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto apsc::interp1D </td>
          <td>(</td>
          <td class="paramtype">RAIterator const &amp;</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RAIterator const &amp;</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key const &amp;</td>          <td class="paramname"><span class="paramname"><em>keyVal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExtractKey const &amp;</td>          <td class="paramname"><span class="paramname"><em>extractKey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExtractValue const &amp;</td>          <td class="paramname"><span class="paramname"><em>extractValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompareKey const &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::less&lt;Key&gt;()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A general piecewise-linear interpolator</p>
<p>This function is the building block for rather general piecewise-liner interpolation It requires to have a range defined by two bidirectional iterators in input. The iterators iterates over a container of a generic type from which we can extract a Key and a Value. The range must be strictly ordered with respect to the key (i.e. without repetition of elements with equivalent keys). The ordering relation must be specified as argument, together as the functors that extract the key and the value from the container, respectively. It is also assumed that usual arithmetic operations may be performed on keys and values.</p>
<p>If the value of the key where to interpolate falls between the interval defined by the keys in the range, piecewise-linear interpolation is performed. Otherwise, extrapolation is performed using the last or first two elements of the container, depending on the case.</p>
<p>The procedure followed is a binary search (bisection) on the keys.</p>
<p>Complexity: if the iterator is a forward iterator the complexity is log2 N, N being the size of the range. otherwise complexity is basically linear, because we need to advance iterators and this is linear on non forward iterators</p>
<dl class="section note"><dt>Note</dt><dd>We recall that the range is defined by [begin, end[</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RAIterator</td><td>A bi-directional iterator </td></tr>
    <tr><td class="paramname">Key</td><td>The type of the Key </td></tr>
    <tr><td class="paramname">ExtractKey</td><td>The type of the functor that extracts the key form a dereferenced iterator </td></tr>
    <tr><td class="paramname">ExtractValue</td><td>The type of functor that extracts the value form a dereferenced iterator </td></tr>
    <tr><td class="paramname">CompareKey</td><td>Type of comparison operator between keys </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Start of the range </td></tr>
    <tr><td class="paramname">end</td><td>End of the range </td></tr>
    <tr><td class="paramname">keyVal</td><td>The value of the key to interpolate </td></tr>
    <tr><td class="paramname">extractKey</td><td>The actual functor for extraction of key </td></tr>
    <tr><td class="paramname">extractValue</td><td>The actual functor for extraction of values </td></tr>
    <tr><td class="paramname">comp</td><td>The comparison operator for keys (defaulted to std::less&lt;Key&gt;() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value found in correspondence of keyVal. Type is automatically deduced. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>I need to have at least two interpolation nodes. </dd>
<dd>
Interpolation nodes must be distinct and sorted. </dd>
<dd>
Iterators must be (at least) bidirectional. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">a</td><td>runtime standard exception if I do not have at least 2 interpolation nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo</a></b></dt><dd>We can make it better if we use the new renge concepts and range based algorithms </dd></dl>
<p>interval found</p>

</div>
</div>
<a id="af42f1a3f2a0ca0a664a4efb87c73b2d3" name="af42f1a3f2a0ca0a664a4efb87c73b2d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42f1a3f2a0ca0a664a4efb87c73b2d3">&#9670;&#160;</a></span>interp1D() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A, typename CompOper = std::less&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double apsc::interp1D </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; A &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const &amp;</td>          <td class="paramname"><span class="paramname"><em>keyVal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompOper const &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::less&lt;double&gt;{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation for vector&lt;T&gt; where T behaves like an array with 2 components (key value).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>A type with operator[i] which for i=0 returns the key (x coordinate) and for i=1 returns the value (y coordinate) </td></tr>
    <tr><td class="paramname">CompOper</td><td>Comparison operator. Defaults to less&lt;double&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a vector with the interpolation points </td></tr>
    <tr><td class="paramname">keyVal</td><td>the point to be interpolated </td></tr>
    <tr><td class="paramname">comp</td><td>Comparison operator, defaults to less&lt;double&gt;() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a3acb7b938f37e927b7ecf171e828463a" name="a3acb7b938f37e927b7ecf171e828463a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3acb7b938f37e927b7ecf171e828463a">&#9670;&#160;</a></span>interp1D() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename CompOper = std::less&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T apsc::interp1D </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>keys</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const &amp;</td>          <td class="paramname"><span class="paramname"><em>keyVal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompOper const &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::less&lt;double&gt;{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation when interpolation nodes and values are stored in two different vectors</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of values to be interpolated </td></tr>
    <tr><td class="paramname">CompOper</td><td>The comparison operator among keys (default less&lt;double&gt;) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The vector containing the keys (interpolation nodes) </td></tr>
    <tr><td class="paramname">values</td><td>The vector containing the values (interpolation values) </td></tr>
    <tr><td class="paramname">keyVal</td><td>The value of the key where I have to interpolate </td></tr>
    <tr><td class="paramname">comp</td><td>The comparison operator (defaulted to less&lt;double&gt;{}). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceapsc.html">apsc</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.1 </li>
  </ul>
</div>
</body>
</html>
