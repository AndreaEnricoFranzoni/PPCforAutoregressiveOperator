}
pValues_1 = numeric(length(delta.grid))
for (i in delta.grid) {
pValues_1[i]=single_test(votes.pre,votes.post,delta.grid[i],B)
}
sample(1:23)
sample(1:23,replace = F)
single_test=function (data1,data2,delta,B){
mu_1 = mean(data1)
mu_2 = mean(data2) - delta
t0 = abs(mu_2 - mu_1)
sample_pooled = rbind(data1,data2)
n = length(sample_pooled)
n1= length(data1)
t_perm = numeric(B)
for (i in 1:B) {
sample_perm = sample(sample_pooled, replace = F)
sample_perm1 = sample_perm[1:n1]
sample_perm2 = sample_perm[(n1+1):n]
t_perm[i] = abs((mean(sample_perm2)-delta)-mean(sample_perm1))
}
pval = sum(t_perm>=t0)/B
return(pval)
}
pValues_1 = numeric(length(delta.grid))
for (i in delta.grid) {
pValues_1[i]=single_test(votes.pre,votes.post,delta.grid[i],B)
}
library(Rcpp)
RcppEigen::RcppEigen.package.skeleton("project_test")
RcppEigen.package.skeleton("project_test")
install.packages("RcppEigen")
install.packages("RcppEigen")
install.packages("RcppEigen")
install.packages("RcppEigen")
X = matrix(c(1,6,3,4,9,6,7,12,9,10,15,12),4,3)
X
X = matrix(c(1,4,7,10,6,9,12,15,3,6,9,12),4,3)
X
gamma = tcrossprod(X)
gamma
gamma = gamma/3
F = tcrossprod(X[,2:3],X[,1:2])
F
F = F/2
F_2 = crossprod(F)
F_2 = t(F)*F
F_""
F_2
I = diag(ones(4),4,4)
I = diag(c(1,1,1,1),4,4)
I
alpha = 0.75
gamma_alpha = gamma + alpha*I
gamma
gamma_alpha
eig = eigen(gamma_alpha)
eig_val = eig$values
eig_val
sum(eig_val)
eig_val_norm = eig_val/sum(eig_val)
eig_val_norm
eig_vec = eig$vectors
eig_vec_ret = eig_vec[,1]
eig_vec_ret
eig_vec_ret = as.matrix(eig_vec_ret)
View(eig_vec_ret)
eig_vec_ret
L_alpha = 1/sqrt(eig_val[1])
L_alpha
gamma_alpha_sq_rt_inv = eig_vec_ret%*%L_alpha%*%t(eig_vec_ret)
gamma_alpha_sq_rt_inv
phi = gamma_alpha_sq_rt_inv%*%F_2%*%gamma_alpha_sq_rt_inv
eig_phi = eigen(phi)
eig_val_phi = eig_phi$values
eig_vec_phi = eig_phi$vectors
V = eig_vec_phi[,1]
rho = F%*%gamma_alpha_sq_rt_inv%*%V%*%t(V)%*%gamma_alpha_sq_rt_inv
rho
a = gamma_alpha_sq_rt_inv*V
a = gamma_alpha_sq_rt_inv%*%V
b = F%*%gamma_alpha_sq_rt_inv%*%V
rho_c = a%*%t(b)
rho
rho_c
X = matrix(c(1,4,7,10,6,9,12,15,3,6,9,12),4,3)
means = colMeans(X)
x_norm = X - means
x_norm
gamma = tcrossprod(X)
gamma
gamma = tcrossprod(x_norm)
gamma
means = rowMeans(X)
x_norm = X - means
x_norm
gamma = tcrossprod(x_norm)
gamma
gamma = tcrossprod(x_norm)/3
gamma
F = tcrossprod(X[,2:3],X[,1:2])/2
F
F = tcrossprod(X[,2:3],X[,1:2])
F
F = tcrossprod(x_norm[,2:3],x_norm[,1:2])
F = F/2
F
F_2 = t(F)*F
F_2
I = diag(c(1,1,1,1),4,4)
gamma_alpha = gamma + alpha*I
alpha = 0.75
gamma_alpha = gamma + alpha*I
gamma_alpha
eig = eigen(gamma_alpha)
eig_val = eig$values
eig_val
eig_val_norm = eig_val/sum(eig_val)
eig_val_norm
0.8868715 + 0.0377095 + 0.0377095
0.8868715 + 0.0377095
eig_vec = eig$vectors
eig_vec
eig_vec_ret = eig_vec[,1:3]
eig_vec_ret
L.alpha <- diag(1/sqrt(eig_val[1:3]))
L.alpha
W.alpha = matrix(eig_vec_ret)
W.alpha = matrix(eig_vec_ret,4,3)
W.alpha
gamma_alpha_inv_sq_rt = W.alpha%*%L.alpha%*%t(W.alpha)
gamma_alpha_inv_sq_rt
phi = gamma_alpha_sq_rt_inv%*%F_2%*%gamma_alpha_sq_rt_inv
phi = gamma_alpha_inv_sq_rt%*%F_2%*%gamma_alpha_inv_sq_rt
phi
> eig_phi = eigen(phi) eig_val_phi = eig_phi$values
eig_phi = eigen(phi)
eig_vals_phi = eig_phi$values
eig_vc_phi = eig_phi$vectors
eig_vals_phi
eig_vc_phi
eig_vc_phi_ret = eig_vc_phi[,1:3]
eig_vc_phi_ret
rho = F%*%gamma_alpha_sq_rt_inv%*%V%*%t(V)%*%gamma_alpha_sq_rt_inv
rho = F%*%gamma_alpha_inv_sq_rt%*%V%*%t(V)%*%gamma_alpha_inv_sq_rt
V = eig_vc_phi_ret
rho = F%*%gamma_alpha_inv_sq_rt%*%V%*%t(V)%*%gamma_alpha_inv_sq_rt
rho
a = gamma_alpha_sq_rt_inv%*%
fe
a = gamma_alpha_sq_rt_inv%*%V
a = gamma_alpha_inv_sq_rt%*%V
a
b = gamma_alpha_inv_sq_rt%*%V
b
a = F%*%b
a
rho_c = a%*%t(b)
rho_c
rho%*%x_norm[,3]
pred = rho%*%x_norm[,3] + means
pred
pred
PPCdiscretized_KO <- function(X, p.thresh=0.95, alpha=NULL, K=NULL)
{
n <- dim(X)[2]
TT <- dim(X)[1] # number of measurements points (of sampling points on the functional domain)
# row.means <- rowMeans(X)
# X <- X - row.means
## Estimation of the covariance and its inverse over the subspace spanned by the first
## K eigenvectors
autocov <- tcrossprod(X)/n
crosscov <- tcrossprod(X[,2:n], X[,1:(n-1)])/(n-1)
if(is.null(alpha)){
alpha <- 0.75
}
Gamma1_2 <- t(crosscov) %*% crosscov
Gamma0 <- autocov + alpha*diag(TT)
eigendecB <- eigen(Gamma0)
lambda.alpha <- eigendecB$values
W.alpha <- eigendecB$vectors
p <- head(which(cumsum(lambda.alpha)/sum(lambda.alpha)>=p.thresh),n=1)
if(p>1){L.alpha <- diag(1/sqrt(lambda.alpha[1:p]))}else{L.alpha <- 1/sqrt(lambda.alpha)[1]}
W.alpha <- matrix(W.alpha[,1:p], nrow=dim(W.alpha)[1], ncol=p)
sqGamma0.inv <- W.alpha %*% L.alpha %*% t(W.alpha)
Phi <- sqGamma0.inv %*% Gamma1_2 %*% sqGamma0.inv
eigendec <- eigen(Phi)
V1 <- eigendec$vectors
D1 <- eigendec$values
V1 <- V1[,order(D1, decreasing=TRUE)]
D1 <- sort(D1, decreasing=TRUE)
if(is.null(K)){
K <- p
}
Vhat1 <- V1[,1:K]
Dhat1 <- D1[1:K]
VVT <- Vhat1 %*% t(Vhat1)
Psi.hat <- crosscov %*% sqGamma0.inv %*% VVT %*% sqGamma0.inv
return(Psi.hat)
}
rho_fun = PPCdiscretized_KO(X)
rho_fun
rho_fun%*%X
rho_fun%*%X[,3]
rho
rho_fun
rho%*%X
rho%*%X[,3]
rho%*%X[,3] + means
rho%*%x_norm[,3] + means
X = matrix(c(1,4,7,10,6,9,12,15,3,6,9,12),4,3)
means = rowMeans(X)
x_norm = X - means
gamma = tcrossprod(x_norm)/3
F = tcrossprod(x_norm[,2:3],x_norm[,1:2])/2
F_2 = t(F)*F
I = diag(c(1,1,1,1),4,4)
alpha = 0.75
gamma_alpha = gamma + alpha*I
eig = eigen(gamma_alpha)
eig_val = eig$values
eig_val
eig_val_norm = eig_val/sum(eig_val)
eig_val_norm
p=3
eig_vec = eig$vectors
eig_vec
eig_vec_ret = eig_vec[,1:p]
eig_vec_ret
L.alpha <- diag(1/sqrt(eig_val[1:p]))
L.alpha
W.alpha = matrix(eig_vec_ret,4,3)
W.alpha
gamma_alpha_inv_sq_rt = W.alpha%*%L.alpha%*%t(W.alpha)
phi = gamma_alpha_inv_sq_rt%*%F_2%*%gamma_alpha_inv_sq_rt
eig_phi = eigen(phi)
V = eig_phi$vectors[,1:p]
rho = F%*%gamma_alpha_inv_sq_rt%*%V%*%t(V)%*%gamma_alpha_inv_sq_rt
b = gamma_alpha_inv_sq_rt%*%V
a = F%*%b
rho_c = a%*%t(b)
pred = rho%*%x_norm[,3] + means
rho
rho_c
PPCdiscretized_KO <- function(X, p.thresh=0.95, alpha=NULL, K=NULL)
{
n <- dim(X)[2]
TT <- dim(X)[1] # number of measurements points (of sampling points on the functional domain)
# row.means <- rowMeans(X)
X <- X - row.means
## Estimation of the covariance and its inverse over the subspace spanned by the first
## K eigenvectors
autocov <- tcrossprod(X)/n
crosscov <- tcrossprod(X[,2:n], X[,1:(n-1)])/(n-1)
if(is.null(alpha)){
alpha <- 0.75
}
Gamma1_2 <- t(crosscov) %*% crosscov
Gamma0 <- autocov + alpha*diag(TT)
eigendecB <- eigen(Gamma0)
lambda.alpha <- eigendecB$values
W.alpha <- eigendecB$vectors
p <- head(which(cumsum(lambda.alpha)/sum(lambda.alpha)>=p.thresh),n=1)
if(p>1){L.alpha <- diag(1/sqrt(lambda.alpha[1:p]))}else{L.alpha <- 1/sqrt(lambda.alpha)[1]}
W.alpha <- matrix(W.alpha[,1:p], nrow=dim(W.alpha)[1], ncol=p)
sqGamma0.inv <- W.alpha %*% L.alpha %*% t(W.alpha)
Phi <- sqGamma0.inv %*% Gamma1_2 %*% sqGamma0.inv
eigendec <- eigen(Phi)
V1 <- eigendec$vectors
D1 <- eigendec$values
V1 <- V1[,order(D1, decreasing=TRUE)]
D1 <- sort(D1, decreasing=TRUE)
if(is.null(K)){
K <- p
}
Vhat1 <- V1[,1:K]
Dhat1 <- D1[1:K]
VVT <- Vhat1 %*% t(Vhat1)
Psi.hat <- crosscov %*% sqGamma0.inv %*% VVT %*% sqGamma0.inv
return(Psi.hat)
}
rho_fun = PPCdiscretized_KO(X)
PPCdiscretized_KO <- function(X, p.thresh=0.95, alpha=NULL, K=NULL)
{
n <- dim(X)[2]
TT <- dim(X)[1] # number of measurements points (of sampling points on the functional domain)
row.means <- rowMeans(X)
X <- X - row.means
## Estimation of the covariance and its inverse over the subspace spanned by the first
## K eigenvectors
autocov <- tcrossprod(X)/n
crosscov <- tcrossprod(X[,2:n], X[,1:(n-1)])/(n-1)
if(is.null(alpha)){
alpha <- 0.75
}
Gamma1_2 <- t(crosscov) %*% crosscov
Gamma0 <- autocov + alpha*diag(TT)
eigendecB <- eigen(Gamma0)
lambda.alpha <- eigendecB$values
W.alpha <- eigendecB$vectors
p <- head(which(cumsum(lambda.alpha)/sum(lambda.alpha)>=p.thresh),n=1)
if(p>1){L.alpha <- diag(1/sqrt(lambda.alpha[1:p]))}else{L.alpha <- 1/sqrt(lambda.alpha)[1]}
W.alpha <- matrix(W.alpha[,1:p], nrow=dim(W.alpha)[1], ncol=p)
sqGamma0.inv <- W.alpha %*% L.alpha %*% t(W.alpha)
Phi <- sqGamma0.inv %*% Gamma1_2 %*% sqGamma0.inv
eigendec <- eigen(Phi)
V1 <- eigendec$vectors
D1 <- eigendec$values
V1 <- V1[,order(D1, decreasing=TRUE)]
D1 <- sort(D1, decreasing=TRUE)
if(is.null(K)){
K <- p
}
Vhat1 <- V1[,1:K]
Dhat1 <- D1[1:K]
VVT <- Vhat1 %*% t(Vhat1)
Psi.hat <- crosscov %*% sqGamma0.inv %*% VVT %*% sqGamma0.inv
return(Psi.hat)
}
rho_fun = PPCdiscretized_KO(X)
rho_fun
rho_fun*x_norm[,3]
rho_fun%*%x_norm[,3]
pred_fun = rho_fun%*%x_norm[,3]  + means
pred_fun
load("~/Documents/Politecnico/Magistrale/Tesi/Dati_CampiFlegrei/DATA/decumulated_temporal_sequence.RData")
library(fda)
data <- t(CanadianWeather$dailyAv[,,1])     #temperature daily
View(data)
library(Rcpp)
library(RcppEigen)
library(devtools)
devtools::install_github("AndreaEnricoFranzoni/PPCforAutoregressiveOperator", force = TRUE)
rm(list=ls())
graphics.off()
setwd("~/Documents/Politecnico/Magistrale/PACS/PPCforAutoregressiveOperator/tests")
#set working directory to source file location
wd=getwd()
#functions and utilities needed
source(paste0(wd,"/Data/far_1_generation/requirements.R"))
source(paste0(wd,"/Data/far_1_generation/far_1.R"))
source(paste0(wd,"/Data/far_1_generation/functions.R"))
source(paste0(wd,"/Data/far_1_generation/prediction_error.R"))
rm(wd)
cat("\014")
id_CV_ko = "CV"           #Ko algorithm
#data: look at "far_1.R" for this parameters (only four kernels, two norm, three errors implemented)
id_kernel <- "gaussian"   #way of generating data
norm      <- 0.8      #Kernel constant (for the L2 norm of the kernel that has to be <1)
id_noise  <- "1"      #error of the FAR(1) process
proc = feat_far_1_process(id_kernel,norm)
id_kernel   <- proc$kernel
a           <- proc$constant
name_kernel <- proc$name
## Parameters --------------------------------------------------------------------------
n <- 100                  #time instants of the functional temporal series
burnin <- 50              #burnin iterations for FAR(1)
N <- n - burnin
#grid for the FAR(1)
t.grid <- seq(0,1, length.out=200)
s.grid <- seq(0,1, length.out=200)
grid <- expand.grid(t.grid, s.grid)
## Simulate the data
set.seed(23032000)
## Monte Carlo simulation ------------------------------------------------------------
{
#errors vector
err.dPPC.KO_en <- numeric(N)     #PF:  Kargin-Onatski PPC
err.dPPC.KO_rn <- numeric(N)
err.dEK_en     <- numeric(N)     #EK:  Kokoszka Estimated Kernel
err.dEK_rn     <- numeric(N)
err.dEKI_en    <- numeric(N)     #EKI: Kokoszka Estimated Kernel Improved
err.dEKI_rn    <- numeric(N)
err.perf_en    <- numeric(N)     #EX:  exact prediction
err.perf_rn    <- numeric(N)
err.mean_en    <- numeric(N)     #MP:  mean prediction
err.mean_rn    <- numeric(N)
err.naive_en   <- numeric(N)     #NP:  naive prediction
err.naive_rn   <- numeric(N)
## 1. Simulate a stationary FAR(1) process according to a specific kernel
X.sample <- far_1(kernel_id = id_kernel, noise_id = id_noise, n = n, t.grid = t.grid, a = a, burnin = burnin)
#to predict data with the exact value
exact_pred = innovation(id_kernel)
## 2. Center the observations
X.eval <- t(scale(t(X.sample), center=TRUE, scale=FALSE))
Xmean.eval <- rowMeans(X.sample)
pb <- progress::progress_bar$new(
format = " MC simulation [:bar] :percent in :elapsed",
total = N, clear = FALSE, width= 60)
for(b in 1:N) #b=1
{
#train and test set (also are necessary with data non centered)
X.train <- X.eval[,b:(N-1+b)]
X.test <- X.eval[,N+b]
X.train_no_cent = X.sample[,b:(N-1+b)]
X.test_no_cent = X.sample[,N+b]
## 3. Estimate Psi with different methods
KO_algo        <- PPCKO::PPC_KO( X = X.train_no_cent, id_CV = id_CV_ko, id_p_for_k = "No", threshold_k = 0.95)
Psihat.dPPC.KO <- KO_algo$rho_hat
Psihat.dEK     <- EKdiscretized(X=X.train,p=3)
Psihat.dEKI    <- EKimproved(X=X.train,p=3)
## 4. Evaluate the error on the test function
#PF
Xhat.dPPC.KO      <- KO_algo$predictions
err.dPPC.KO_en[b] <- En(X.test_no_cent,Xhat.dPPC.KO,t.grid)
err.dPPC.KO_rn[b] <- Rn(X.test_no_cent,Xhat.dPPC.KO,t.grid)
#EK
Xhat.dEK      <- Psihat.dEK %*% X.train[,N] + Xmean.eval
err.dEK_en[b] <- En(X.test_no_cent,Xhat.dEK,t.grid)
err.dEK_rn[b] <- Rn(X.test_no_cent,Xhat.dEK,t.grid)
#EKI
Xhat.dEKI   <- Psihat.dEKI %*% X.train[,N] + Xmean.eval
err.dEKI_en[b] <- En(X.test_no_cent,Xhat.dEKI,t.grid)
err.dEKI_rn[b] <- Rn(X.test_no_cent,Xhat.dEKI,t.grid)
#EX
Xhat.perf   <- exact_pred(y=X.sample[,(N-1+b)], t.grid=t.grid, a=a)
err.perf_en[b] <- En(X.test,Xhat.perf,t.grid)
err.perf_rn[b] <- Rn(X.test,Xhat.perf,t.grid)
#MP (data centered: the prediction is done with their mean, that is 0)
err.mean_en[b]  <- En(X.test,rep(0,length(t.grid)),t.grid)
err.mean_rn[b]  <- Rn(X.test,rep(0,length(t.grid)),t.grid)
#NP (prediction is done using always the last observation)
err.naive_en[b] <- En(X.test,X.eval[,n],t.grid)
err.naive_rn[b] <- Rn(X.test,X.eval[,n],t.grid)
pb$tick()
}
}
###################
## BoxPlot of En ##
###################
err_en <- c(err.naive_en, err.perf_en, err.mean_en, err.dPPC.KO_en, err.dEK_en, err.dEKI_en)
method <- rep(c("naive","perfect", "mean","PPC-KO", "EK", "EKI"), each=N)
En <- data.frame(method, err_en)
method_order<- c("naive", "perfect", "mean", "PPC-KO", "EK", "EKI")
En.box <- En %>% mutate(method=factor(x=method, levels=method_order))
##grouped boxplot
quartz()
pgplot <- ggplot(En.box, aes(x=method, y=err_en, fill=method)) +
geom_boxplot() + ggtitle(name_kernel)
pgplot <- pgplot +
#scale_y_continuous(limits=c(0,0.1)) +
theme_bw() +
labs(x="", y="En", fill = "Prediction method") +
#labs(x="", y=TeX(r'($\frac{1}{N} \; \sum_{j=1}^N (f_{t+1, j}^b - \hat{f}_{t+1,j}^b)^2$)'), fill="Prediction method") +
theme(plot.title = element_text(face="bold", hjust=0.5, size=22),
axis.text.x = element_text(size=22),
axis.title.x = element_text(size=22),
axis.text.y = element_text(size=22),
axis.title.y = element_text(size=22),
legend.title = element_text(size=22),
legend.text = element_text(size=22),
legend.position="bottom",
legend.direction = "horizontal") +
guides(fill=guide_legend(nrow=1, byrow=TRUE))
pgplot +
theme(legend.position="none")
###################
## BoxPlot of Rn ##
###################
err_rn <- c(err.naive_rn, err.perf_rn, err.mean_rn, err.dPPC.KO_rn, err.dEK_rn, err.dEKI_rn)
method <- rep(c("naive","perfect", "mean","PPC-KO", "EK", "EKI"), each=N)
Rn <- data.frame(method, err_rn)
method_order<- c("naive", "perfect", "mean", "PPC-KO", "EK", "EKI")
Rn.box <- En %>% mutate(method=factor(x=method, levels=method_order))
##grouped boxplot
quartz()
pgplot <- ggplot(Rn.box, aes(x=method, y=err_rn, fill=method)) +
geom_boxplot()  + ggtitle(name_kernel)
pgplot <- pgplot +
#scale_y_continuous(limits=c(0,0.1)) +
theme_bw() +
labs(x="", y="Rn", fill = "Prediction method") +
#labs(x="", y=TeX(r'($\frac{1}{N} \; \sum_{j=1}^N (f_{t+1, j}^b - \hat{f}_{t+1,j}^b)^2$)'), fill="Prediction method") +
theme(plot.title = element_text(face="bold", hjust=0.5, size=22),
axis.text.x = element_text(size=22),
axis.title.x = element_text(size=22),
axis.text.y = element_text(size=22),
axis.title.y = element_text(size=22),
legend.title = element_text(size=22),
legend.text = element_text(size=22),
legend.position="bottom",
legend.direction = "horizontal") +
guides(fill=guide_legend(nrow=1, byrow=TRUE))
pgplot +
theme(legend.position="none")
#mean and standard error of the Ens
mean(err.dPPC.KO_en)
sqrt(var(err.dPPC.KO_en)/length(err.dPPC.KO_en))
mean(err.dEK_en)
sqrt(var(err.dEK_en)/length(err.dEK_en))
mean(err.dEKI_en)
sqrt(var(err.dEKI_en)/length(err.dEKI_en))
mean(err.perf_en)
sqrt(var(err.perf_en)/length(err.perf_en))
mean(err.mean_en)
sqrt(var(err.mean_en)/length(err.mean_en))
mean(err.naive_en)
sqrt(var(err.naive_en)/length(err.naive_en))
#mean and standard error of the Rns
mean(err.dPPC.KO_rn)
sqrt(var(err.dPPC.KO_rn)/length(err.dPPC.KO_rn))
mean(err.dEK_rn)
sqrt(var(err.dEK_rn)/length(err.dEK_rn))
mean(err.dEKI_rn)
sqrt(var(err.dEKI_rn)/length(err.dEKI_rn))
mean(err.perf_rn)
sqrt(var(err.perf_rn)/length(err.perf_rn))
mean(err.mean_rn)
sqrt(var(err.mean_rn)/length(err.mean_rn))
mean(err.naive_rn)
sqrt(var(err.naive_rn)/length(err.naive_rn))
graphics.off()
