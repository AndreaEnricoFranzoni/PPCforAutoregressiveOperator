gamma = tcrossprod(x_norm)/3
F = tcrossprod(x_norm[,2:3],x_norm[,1:2])/2
F_2 = t(F)*F
I = diag(c(1,1,1,1),4,4)
alpha = 0.75
gamma_alpha = gamma + alpha*I
eig = eigen(gamma_alpha)
eig_val = eig$values
eig_val
eig_val_norm = eig_val/sum(eig_val)
eig_val_norm
p=3
eig_vec = eig$vectors
eig_vec
eig_vec_ret = eig_vec[,1:p]
eig_vec_ret
L.alpha <- diag(1/sqrt(eig_val[1:p]))
L.alpha
W.alpha = matrix(eig_vec_ret,4,3)
W.alpha
gamma_alpha_inv_sq_rt = W.alpha%*%L.alpha%*%t(W.alpha)
phi = gamma_alpha_inv_sq_rt%*%F_2%*%gamma_alpha_inv_sq_rt
eig_phi = eigen(phi)
V = eig_phi$vectors[,1:p]
rho = F%*%gamma_alpha_inv_sq_rt%*%V%*%t(V)%*%gamma_alpha_inv_sq_rt
b = gamma_alpha_inv_sq_rt%*%V
a = F%*%b
rho_c = a%*%t(b)
pred = rho%*%x_norm[,3] + means
rho
rho_c
PPCdiscretized_KO <- function(X, p.thresh=0.95, alpha=NULL, K=NULL)
{
n <- dim(X)[2]
TT <- dim(X)[1] # number of measurements points (of sampling points on the functional domain)
# row.means <- rowMeans(X)
X <- X - row.means
## Estimation of the covariance and its inverse over the subspace spanned by the first
## K eigenvectors
autocov <- tcrossprod(X)/n
crosscov <- tcrossprod(X[,2:n], X[,1:(n-1)])/(n-1)
if(is.null(alpha)){
alpha <- 0.75
}
Gamma1_2 <- t(crosscov) %*% crosscov
Gamma0 <- autocov + alpha*diag(TT)
eigendecB <- eigen(Gamma0)
lambda.alpha <- eigendecB$values
W.alpha <- eigendecB$vectors
p <- head(which(cumsum(lambda.alpha)/sum(lambda.alpha)>=p.thresh),n=1)
if(p>1){L.alpha <- diag(1/sqrt(lambda.alpha[1:p]))}else{L.alpha <- 1/sqrt(lambda.alpha)[1]}
W.alpha <- matrix(W.alpha[,1:p], nrow=dim(W.alpha)[1], ncol=p)
sqGamma0.inv <- W.alpha %*% L.alpha %*% t(W.alpha)
Phi <- sqGamma0.inv %*% Gamma1_2 %*% sqGamma0.inv
eigendec <- eigen(Phi)
V1 <- eigendec$vectors
D1 <- eigendec$values
V1 <- V1[,order(D1, decreasing=TRUE)]
D1 <- sort(D1, decreasing=TRUE)
if(is.null(K)){
K <- p
}
Vhat1 <- V1[,1:K]
Dhat1 <- D1[1:K]
VVT <- Vhat1 %*% t(Vhat1)
Psi.hat <- crosscov %*% sqGamma0.inv %*% VVT %*% sqGamma0.inv
return(Psi.hat)
}
rho_fun = PPCdiscretized_KO(X)
PPCdiscretized_KO <- function(X, p.thresh=0.95, alpha=NULL, K=NULL)
{
n <- dim(X)[2]
TT <- dim(X)[1] # number of measurements points (of sampling points on the functional domain)
row.means <- rowMeans(X)
X <- X - row.means
## Estimation of the covariance and its inverse over the subspace spanned by the first
## K eigenvectors
autocov <- tcrossprod(X)/n
crosscov <- tcrossprod(X[,2:n], X[,1:(n-1)])/(n-1)
if(is.null(alpha)){
alpha <- 0.75
}
Gamma1_2 <- t(crosscov) %*% crosscov
Gamma0 <- autocov + alpha*diag(TT)
eigendecB <- eigen(Gamma0)
lambda.alpha <- eigendecB$values
W.alpha <- eigendecB$vectors
p <- head(which(cumsum(lambda.alpha)/sum(lambda.alpha)>=p.thresh),n=1)
if(p>1){L.alpha <- diag(1/sqrt(lambda.alpha[1:p]))}else{L.alpha <- 1/sqrt(lambda.alpha)[1]}
W.alpha <- matrix(W.alpha[,1:p], nrow=dim(W.alpha)[1], ncol=p)
sqGamma0.inv <- W.alpha %*% L.alpha %*% t(W.alpha)
Phi <- sqGamma0.inv %*% Gamma1_2 %*% sqGamma0.inv
eigendec <- eigen(Phi)
V1 <- eigendec$vectors
D1 <- eigendec$values
V1 <- V1[,order(D1, decreasing=TRUE)]
D1 <- sort(D1, decreasing=TRUE)
if(is.null(K)){
K <- p
}
Vhat1 <- V1[,1:K]
Dhat1 <- D1[1:K]
VVT <- Vhat1 %*% t(Vhat1)
Psi.hat <- crosscov %*% sqGamma0.inv %*% VVT %*% sqGamma0.inv
return(Psi.hat)
}
rho_fun = PPCdiscretized_KO(X)
rho_fun
rho_fun*x_norm[,3]
rho_fun%*%x_norm[,3]
pred_fun = rho_fun%*%x_norm[,3]  + means
pred_fun
#to uploda the packages
#change here the directory
setwd("/Users/andreafranzoni/Documents/Politecnico/Magistrale/PACS/PPCforAutoregressiveOperator")
#then
Rcpp::compileAttributes(".")
library(Rcpp)
library(RcppEigen)
library(devtools)
devtools::install_github("AndreaEnricoFranzoni/PPCforAutoregressiveOperator", force = TRUE)
#to uploda the packages
#change here the directory
setwd("/Users/andreafranzoni/Documents/Politecnico/Magistrale/PACS/PPCforAutoregressiveOperator")
#then
Rcpp::compileAttributes(".")
library(Rcpp)
library(RcppEigen)
library(devtools)
devtools::install_github("AndreaEnricoFranzoni/PPCforAutoregressiveOperator", force = TRUE)
#function to evaluate mse on the predictions
mse = function(x1,x2)
{
n = length(x1)
err = numeric(n)
for (i in 1:n) {
err[i] = (x1[i] - x2[i])^2
}
return((sum(err)/n))
}
#PPC_KO version with R function
PPCdiscretized_KO <- function(X, p.thresh=0.95, alpha=NULL, K=NULL)
{
n <- dim(X)[2]
TT <- dim(X)[1] # number of measurements points (of sampling points on the functional domain)
# row.means <- rowMeans(X)
# X <- X - row.means
## Estimation of the covariance and its inverse over the subspace spanned by the first
## K eigenvectors
autocov <- tcrossprod(X)/n
crosscov <- tcrossprod(X[,2:n], X[,1:(n-1)])/(n-1)
if(is.null(alpha)){
alpha <- 0.75
}
Gamma1_2 <- t(crosscov) %*% crosscov
Gamma0 <- autocov + alpha*diag(TT)
eigendecB <- eigen(Gamma0)
lambda.alpha <- eigendecB$values
W.alpha <- eigendecB$vectors
p <- head(which(cumsum(lambda.alpha)/sum(lambda.alpha)>=p.thresh),n=1)
if(p>1){L.alpha <- diag(1/sqrt(lambda.alpha[1:p]))}else{L.alpha <- 1/sqrt(lambda.alpha)[1]}
W.alpha <- matrix(W.alpha[,1:p], nrow=dim(W.alpha)[1], ncol=p)
sqGamma0.inv <- W.alpha %*% L.alpha %*% t(W.alpha)
Phi <- sqGamma0.inv %*% Gamma1_2 %*% sqGamma0.inv
eigendec <- eigen(Phi)
V1 <- eigendec$vectors
D1 <- eigendec$values
V1 <- V1[,order(D1, decreasing=TRUE)]
D1 <- sort(D1, decreasing=TRUE)
if(is.null(K)){
K <- p
}
Vhat1 <- V1[,1:K]
Dhat1 <- D1[1:K]
VVT <- Vhat1 %*% t(Vhat1)
Psi.hat <- crosscov %*% sqGamma0.inv %*% VVT %*% sqGamma0.inv
return(Psi.hat)
}
#' Hyperparameter selection in an increasing-window fashion
dalpha_select <- function(alpha.vec, XX, K=1)
{
n <- dim(XX)[2]
TT <- dim(XX)[1]
# Errors' vector
err.vec <- numeric(length(alpha.vec))
for(l in 1:length(alpha.vec)) # l=1
{
alpha <- alpha.vec[l]
err.cv <- numeric(0)
for(b in ceiling(n/2):(n-1))
{
X.train  <- XX[,1:b]
n.train  <- dim(X.train)[2]
autocov  <- tcrossprod(X.train)/n.train
crosscov <- tcrossprod(X.train[,2:n.train], X.train[,1:(n.train-1)])/(n.train-1)
## Define and solve the generalized eigenvalues problem
Gamma1_2 <- t(crosscov) %*% crosscov
Gamma0 <- autocov
geigendec <- geigen::geigen(Gamma1_2, Gamma0 + alpha*diag(TT))
V1 <- geigendec$vectors
D1 <- geigendec$values
V1 <- V1[,order(D1, decreasing=TRUE)]
D1 <- sort(D1, decreasing=TRUE)
Vhat1 <- V1[,1:K]
Dhat1 <- D1[1:K]
Psi.hat <- crosscov %*% Vhat1 %*% t(Vhat1)
## Evaluate the error on the test set with alpha
## Psi
y.true <- XX[,(b+1)]
## Psi hat
y.hat <- Psi.hat %*% XX[,b]
err <- y.true - y.hat
err.cv <- c(err.cv,mean(err^2))
}
err.vec[l] <- mean(err.cv)
}
##add this
#print(err.vec)
alpha.opt <- alpha.vec[which.min(err.vec)]
out <- list("alpha.opt" = alpha.opt,
"err.vec"   = err.vec,
"alpha.vec" = alpha.vec)
return(out)
}
library(fda)
data <- t(CanadianWeather$dailyAv[,,1])     #temperature daily
m = dim(data)[1]      #number of temporal series
n = dim(data)[2]      #number of time instants
quartz()
quartz()
set.seed(230300)
#leave these parameters like that for now
cv = "CV_k"
alpha = 0.75
k_s = 1:m
threshold=0.95
#raw data
data_used = data[,1:(n-1)]
exact_result = data[,n]
#c++ based package
#number of PPC taken from reg. covariance
start_time_KO_rc <- Sys.time()
KO_rc = PPCKO::PPC_KO( X = data_used,
id_CV = cv,
id_p_for_k = "No",
threshold_k = threshold,
id_p_imposed = "Yes"
)
pred_KO_rc = KO_rc$predictions
alpha_rc = KO_rc$alpha
k_rc = KO_rc$PPCs_retained
end_time_KO_rc <- Sys.time()
#to here with only one command to measure computational time properly
mse_KO_rc = mse(pred_KO_rc,exact_result)
execution_time_KO_rc <- end_time_KO_rc - start_time_KO_rc
#number of PPC taken from phi
start_time_KO_phi <- Sys.time()
KO_phi = PPCKO::PPC_KO( X = data_used,
id_CV = cv,
id_p_for_k = "No",
threshold_k = threshold,
id_p_imposed = "No"
)
pred_KO_phi = KO_phi$predictions
alpha_phi = KO_phi$alpha
k_phi = KO_phi$PPCs_retained
end_time_KO_phi <- Sys.time()
#to here with only one command to measure computational time properly
mse_KO_phi = mse(pred_KO_phi,exact_result)
execution_time_KO_phi <- end_time_KO_phi - start_time_KO_phi
#R func
start_time_KO_fun <- Sys.time()
k_opt_fun = dK_select(data_used,alpha)$nppc.opt
return(out)
dK_select <- function(XX, alpha)
{
n <- dim(XX)[2]
TT <- dim(XX)[1]
n.train <- round(n/2)
X.train <- XX[,1:n.train]
autocov <- tcrossprod(X.train)/n.train
crosscov <- tcrossprod(X.train[,2:n.train], X.train[,1:(n.train-1)])/(n.train-1)
## Define and solve the generalized eigenvalues problem
Gamma1_2 <- t(crosscov) %*% crosscov
Gamma0 <- autocov
geigendec <- geigen::geigen(Gamma1_2, Gamma0 + alpha*diag(TT))
V1 <- geigendec$vectors
D1 <- geigendec$values
V1 <- V1[,order(D1, decreasing=TRUE)]
D1 <- sort(D1, decreasing=TRUE)
nppc.vec <- which(D1>=1e-4)
nppc.vec <- which(cumsum(D1)/sum(D1) < 1)
err.vec <- numeric(length(nppc.vec))
for(l in 1:length(nppc.vec)) # l=1
{
K <- nppc.vec[l]
Vhat1 <- V1[,1:K]
Dhat1 <- D1[1:K]
Psi.hat <- crosscov %*% Vhat1 %*% t(Vhat1)
## Evaluate the error on the test set with alpha
## Psi
y.true <- XX[,(n.train+2):n]
## Psi hat
y.hat <- Psi.hat %*% XX[,(n.train+1):(n-1)]
err <- y.true - y.hat
err.vec[l] <- sqrt(sum(err^2))
}
nppc.opt <- nppc.vec[which.min(err.vec)]
out <- list("nppc.opt" = nppc.opt,
"err.vec"   = err.vec,
"nppc.vec" = nppc.vec)
return(out)
}
quartz()
set.seed(230300)
#leave these parameters like that for now
cv = "CV_k"
alpha = 0.75
k_s = 1:m
threshold=0.95
#raw data
data_used = data[,1:(n-1)]
exact_result = data[,n]
#c++ based package
#number of PPC taken from reg. covariance
start_time_KO_rc <- Sys.time()
KO_rc = PPCKO::PPC_KO( X = data_used,
id_CV = cv,
id_p_for_k = "No",
threshold_k = threshold,
id_p_imposed = "Yes"
)
pred_KO_rc = KO_rc$predictions
alpha_rc = KO_rc$alpha
k_rc = KO_rc$PPCs_retained
end_time_KO_rc <- Sys.time()
#to here with only one command to measure computational time properly
mse_KO_rc = mse(pred_KO_rc,exact_result)
execution_time_KO_rc <- end_time_KO_rc - start_time_KO_rc
#number of PPC taken from phi
start_time_KO_phi <- Sys.time()
KO_phi = PPCKO::PPC_KO( X = data_used,
id_CV = cv,
id_p_for_k = "No",
threshold_k = threshold,
id_p_imposed = "No"
)
pred_KO_phi = KO_phi$predictions
alpha_phi = KO_phi$alpha
k_phi = KO_phi$PPCs_retained
end_time_KO_phi <- Sys.time()
#to here with only one command to measure computational time properly
mse_KO_phi = mse(pred_KO_phi,exact_result)
execution_time_KO_phi <- end_time_KO_phi - start_time_KO_phi
#R func
start_time_KO_fun <- Sys.time()
k_opt_fun = dK_select(data_used,alpha)$nppc.opt
rho_KO_fun = PPCdiscretized_KO(data_used,p.thresh=threshold,alpha = alpha,K=k_opt_fun)
pred_KO_fun = rho_KO_fun%*%data_used[,n-1]
end_time_KO_fun <- Sys.time()
mse_KO_fun = mse(pred_KO_fun,exact_result)
execution_time_KO_fun <- end_time_KO_fun - start_time_KO_fun
#functional data
time <- 1:n
nbasis = ceiling(n/3)
basis <- create.fourier.basis(rangeval=c(1,n),nbasis=nbasis)
basismat <- eval.basis(time, basis)
est_coef = lsfit(basismat, t(data), intercept = FALSE)$coef
Xsp0 <- basismat %*% est_coef
data_f = t(Xsp0)
row.names(data_f) = row.names(data)
colnames(data_f) = colnames(data)
#quartz()
#x11()
#plot.fd(Data2fd(y = t(data),argvals = time,basisobj = basis),titles = row.names(data))
data_used_f = data_f[,1:(n-1)]
exact_result_f = data_f[,n]
#c++ based package
#number of PPC taken from reg. covariance
start_time_KO_rc_f <- Sys.time()
KO_rc_f = PPCKO::PPC_KO( X = data_used_f,
id_CV = cv,
id_p_for_k = "No",
threshold_k = threshold,
id_p_imposed = "Yes"
)
pred_KO_rc_f = KO_rc_f$predictions
alpha_rc_f = KO_rc_f$alpha
k_rc_f = KO_rc_f$PPCs_retained
end_time_KO_rc_f <- Sys.time()
#to here with only one command to measure computational time properly
mse_KO_rc_f = mse(pred_KO_rc_f,exact_result_f)
execution_time_KO_rc_f <- end_time_KO_rc_f - start_time_KO_rc_f
#number of PPC taken from phi
start_time_KO_phi_f <- Sys.time()
KO_phi_f = PPCKO::PPC_KO( X = data_used_f,
id_CV = cv,
id_p_for_k = "No",
threshold_k = threshold,
id_p_imposed = "No"
)
pred_KO_phi_f = KO_phi_f$predictions
alpha_phi_f = KO_phi_f$alpha
k_phi_f = KO_phi_f$PPCs_retained
end_time_KO_phi_f <- Sys.time()
#to here with only one command to measure computational time properly
mse_KO_phi_f = mse(pred_KO_phi_f,exact_result_f)
execution_time_KO_phi_f <- end_time_KO_phi_f - start_time_KO_phi_f
#R func
start_time_KO_fun_f <- Sys.time()
k_opt_fun_f = dK_select(data_used_f,alpha)$nppc.opt
rho_KO_fun_f = PPCdiscretized_KO(data_used_f,p.thresh=threshold,alpha = alpha,K=k_opt_fun_f)
pred_KO_fun_f = rho_KO_fun_f%*%data_used_f[,n-1]
end_time_KO_fun_f <- Sys.time()
mse_KO_fun_f = mse(pred_KO_fun_f,exact_result_f)
execution_time_KO_fun_f <- end_time_KO_fun_f - start_time_KO_fun_f
print("CV k comparison")
print("Raw data")
print("Time for KO with C++ imposing k from reg cov:")
print(execution_time_KO_rc)
print("Time for KO with C++ imposing k from phi:")
print(execution_time_KO_phi)
print("Time for KO with R function:")
print(execution_time_KO_fun)
print("MSE for KO with C++ imposing k from reg cov:")
print(mse_KO_rc)
print("MSE for KO with C++ imposing k from phi:")
print(mse_KO_phi)
print("MSE for KO with R function:")
print(mse_KO_fun)
print("k for KO with C++ imposing k from reg cov:")
print(KO_rc$PPCs_retained)
print("k for KO with C++ imposing k from phi:")
print(KO_phi$PPCs_retained)
print("k for KO withR func:")
print(k_opt_fun)
print("Functional data")
print("Time for KO with C++ imposing k from reg cov:")
print(execution_time_KO_rc_f)
print("Time for KO with C++ imposing k from phi:")
print(execution_time_KO_phi_f)
print("Time for KO with R function:")
print(execution_time_KO_fun_f)
print("MSE for KO with C++ imposing k from reg cov:")
print(mse_KO_rc_f)
print("MSE for KO with C++ imposing k from phi:")
print(mse_KO_phi_f)
print("MSE for KO with R function:")
print(mse_KO_fun_f)
print("k for KO with C++ imposing k from reg cov:")
print(KO_rc_f$PPCs_retained)
print("k for KO with C++ imposing k from phi:")
print(KO_phi_f$PPCs_retained)
print("k for KO withR func:")
print(k_opt_fun_f)
quartz()
par(mfrow=c(2,2))
plot(k_s,KO_rc$valid_errors,main = "C++ based KO from reg cov raw",xlab = "k",ylab="Validation errors",type = "l")
plot(k_s,KO_phi$valid_errors,main = "C++ based KO from phi raw",xlab = "k",ylab="Validation errors", type="l")
plot(k_s,KO_rc_f$valid_errors,main = "From reg cov fun",xlab = "k",ylab="Validation errors", type="l")
plot(k_s,KO_phi_f$valid_errors,main = "From phi f",xlab = "k",ylab="Validation errors", type="l")
#errors
mses_ko = numeric(length = length(k_s))
mses_ko_f = numeric(length = length(k_s))
mses_fun = numeric(length = length(k_s))
mses_fun_f = numeric(length = length(k_s))
for (i in 1:length(k_s)) {
pred_loop_ko = PPCKO::PPC_KO(data_used,"NoCV","No",threshold,alpha = alpha,k=k_s[i])
pred_loop_ko_f = PPCKO::PPC_KO(data_used_f,"NoCV","No",threshold,alpha = alpha,k=k_s[i])
pred_loop_fun = PPCdiscretized_KO(data_used,alpha = alpha,K=k_s[i])%*%data_used[,n-1]
pred_loop_fun_f = PPCdiscretized_KO(data_used_f,alpha = alpha,K=k_s[i])%*%data_used_f[,n-1]
mses_ko[i] = mse(pred_loop_ko$predictions,exact_result)
mses_ko_f[i] = mse(pred_loop_ko_f$predictions,exact_result_f)
mses_fun[i] = mse(pred_loop_fun,exact_result)
mses_fun_f[i] = mse(pred_loop_fun_f,exact_result_f)
}
#raw data
y_low = min(min(min(mses_ko),min(mses_fun)),min(KO_rc$valid_errors))
y_up = max(max(max(mses_ko),max(mses_fun)),max(KO_rc$valid_errors))
#functional data data
y_low_f = min(min(min(mses_ko_f),min(mses_fun_f)),min(KO_rc_f$valid_errors))
y_up_f = max(max(max(mses_ko_f),max(mses_fun_f)),max(KO_rc_f$valid_errors))
#run from there to the end all together
quartz()
par(mfrow=c(2,1))
plot(k_s,mses_ko,col='black',cex=0.5,type = "l",main="Raw data",
xlab="k",ylab="Errors",ylim=c(y_low,y_up))
abline(v=k_s[which(mses_ko==min(mses_ko))],col='black')
points(k_s,KO_rc$valid_errors,cex=0.5,type = "l",col='green')
abline(v=k_s[which(KO_rc$valid_errors==min(KO_rc$valid_errors))],col='green')
points(k_s,mses_fun,cex=0.5,type = "l",col='blue')
abline(v=k_s[which(mses_fun==min(mses_fun))],col='blue')
legend("topright",
legend = c("Test error KO C++ based",
"Validation error KO C++ based",
"Test error KO R fun based"),
fill  = c("black","green","blue")
)
plot(k_s,mses_ko_f,col='black',cex=0.5,type = "l",main="Functional data",
xlab="Alpha",ylab="Errors",ylim=c(y_low,y_up))
abline(v=k_s[which(mses_ko_f==min(mses_ko_f))],col='black')
points(k_s,KO_rc_f$valid_errors,cex=0.5,type = "l",col='green')
abline(v=k_s[which(KO_rc_f$valid_errors==min(KO_rc_f$valid_errors))],col='green')
points(k_s,mses_fun_f,cex=0.5,type = "l",col='blue')
abline(v=k_s[which(mses_fun_f==min(mses_fun_f))],col='blue')
legend("topright",
legend = c("Test error KO C++ based",
"Validation error KO C++ based",
"Test error KO R fun based"),
fill  = c("black","green","blue")
)
graphics.off()
